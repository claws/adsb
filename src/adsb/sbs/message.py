"""
This module implements classes and functions to assist with parsing
a SBS format message line into a :class:`SBSMessage` object and back
again.
"""

import collections
import datetime
import enum
import json
import logging

from typing import Union

logger = logging.getLogger(__name__)


DELIMITER = "\r\n"


class MessageType(object):
    """
    This class defines the different SBS message types.

    Transmission messages contain information sent by aircraft. All others
    are produced by the application supplying the SBS feed.
    """
    # Generated when the user changes the selected aircraft in
    # BaseStation.
    Selection_Change = "SEL"

    # Generated when an aircraft being tracked sets or changes its
    # callsign.
    New_Id = "ID"

    # Generated when the SBS picks up a signal for an aircraft that it
    # isn't currently tracking.
    New_Aircraft = "AIR"

    # Generated when an aircraft's status changes according to the
    # time-out values in the SBS1 Data Settings menu.
    Status_Aircraft = "STA"

    # Generated when the user double-clicks on an aircraft (i.e.
    # to bring up the aircraft details window).
    Click = "CLK"

    # Messages generated by the aircraft. There are eight different
    # MSG transmission types, see `TransmissionType`.
    Transmission = "MSG"


class TransmissionType(enum.Enum):
    """
    Only `ES_SURFACE_POS` and `ES_AIRBORNE_POS` transmissions have
    position (latitude and longitude) information.

    ES = Entended Squitter
    DF = Downlink Format
    BDS = B-Definition Subfield
    """
    ES_IDENT_AND_CATEGORY = 1
    ES_SURFACE_POS = 2
    ES_AIRBORNE_POS = 3
    ES_AIRBORNE_VEL = 4

    # Triggered by ground radar.
    SURVEILLANCE_ALT = 5
    SURVEILLANCE_ID = 6

    # Triggered by TCAS.
    AIR_TO_AIR = 7

    # Broadcast. Also triggered by ground radar.
    ALL_CALL_REPLY = 8


class Fields(enum.Enum):
    """ SBS protocol message fields.

    Fields a declared in the order they appear in a message.
    """
    # See :class:`MessageType`
    message_type = 0
    # See :class:`TransmissionType`
    transmission_type = 1
    # SBS Database session record number.
    session_id = 2
    # SBS Database aircraft record number.
    aircraft_id = 3
    # 24-bit ICAO ID in hex.
    hex_ident = 4
    # SBS Database flight record number.
    flight_id = 5
    # Date the message was generated.
    generated_date = 6
    # Time the message was generated.
    generated_time = 7
    # Date the message was logged by SBS
    logged_date = 8
    # Time the message was logged by SBS.
    logged_time = 9
    # Eight character flight ID or callsign.
    callsign = 10
    # Altitude (ft) relative to 1013 mb (29.92" Hg).
    altitude = 11
    # Speed over ground (kt)
    ground_speed = 12
    # ground heading
    track = 13
    # Latitude in degrees
    lat = 14
    # Longitude in degrees
    lon = 15
    # Rate of climb
    vertical_rate = 16
    # Squawk
    squawk = 17
    # Squawk flag - indicating squawk has changed.
    alert = 18
    # Squawk flag indicating emergency code has been set.
    emergency = 19
    # Flag indicating the Special Position Indicator has been set.
    spi = 20
    # Flag indicating whether aircraft is on the ground
    is_on_ground = 21


# Allocate fields into groups that can use the same parser function
IntegerFields = [
    Fields.transmission_type.name,
    Fields.session_id.name,
    Fields.aircraft_id.name,
    Fields.flight_id.name,
    Fields.altitude.name,
    Fields.ground_speed.name,
    Fields.track.name,
    Fields.vertical_rate.name,
    Fields.is_on_ground.name,
]

BooleanFields = [
    Fields.spi.name,
    Fields.alert.name,
    Fields.emergency.name,
    Fields.is_on_ground.name,
]

DateFields = [Fields.generated_date.name, Fields.logged_date.name]

FloatFields = [Fields.lat.name, Fields.lon.name]

StringFields = [Fields.hex_ident.name, Fields.callsign.name]

TimeFields = [Fields.generated_time.name, Fields.logged_time.name]

FieldNames = list(name for name in Fields.__members__)

SBSMessage = collections.namedtuple("SBSMessage", FieldNames)


def fromString(line: Union[bytes, str]) -> SBSMessage:
    """
    Parse a SBS format message string into a SBSMessage object.

    :param line: A bytes or string object representing a SBS format message.

    """
    if isinstance(line, bytes):
        line = line.decode()

    values = line.rstrip(DELIMITER).split(",")

    if len(FieldNames) != len(values):
        raise Exception(
            "Incorrect number of msg fields. "
            f"Expected {len(FieldNames)}, got {len(values)}. "
            f"values={values}, line={line}"
        )

    attrs = {}
    for k, v in zip(FieldNames, values):
        v = v.strip()  # remove any surrounding spaces
        if v:
            # perform type conversion if necessary
            if k in IntegerFields:
                v = int(v)
            elif k in FloatFields:
                v = float(v)
            elif k in BooleanFields:
                v = True if v == "1" else False
            elif k in DateFields:
                Y, M, D = [int(i) for i in v.split("/")]
                v = datetime.date(Y, M, D)
            elif k in TimeFields:
                H, M, S = v.split(":")
                S, F = S.split(".")
                microsecond = int(int(F) * 1e3)
                v = datetime.time(
                    hour=int(H), minute=int(M), second=int(S), microsecond=microsecond
                )
            # elif k in StringFields:
            #     v = v.strip()
            # else:
            #     # field is expected to be a string field
            #     logger.warning(
            #         'Unexpected field name: {}'.format(k))
        else:
            v = None

        attrs[k] = v

    return SBSMessage(**attrs)


def toString(m: SBSMessage) -> bytes:
    """ Convert a SBS message object to s SBS format string """
    o = []
    for field, v in zip(FieldNames, m):
        # perform conversion if necessary
        if field in (Fields.lat.name, Fields.lon.name):
            o.append("" if v is None else f"{v:.5f}")
        elif field in DateFields:
            o.append(datetime.date.strftime(v, "%Y/%m/%d"))
        elif field in TimeFields:
            o.append(
                datetime.time.strftime(v, "%H:%M:%S")
                + f".{int(v.microsecond/1000):03d}"
            )
        elif field in BooleanFields:
            if v is None:
                v = ""
            else:
                v = "1" if v is True else "0"
            o.append(v)
        else:
            o.append("" if v is None else str(v))

    return ",".join(o).encode() + DELIMITER.encode()
